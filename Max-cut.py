# -*- coding: UTF-8 -*-
from cvxopt import matrix, normal, spdiag, misc, lapack, sparse
from ubsdp import ubsdp

"""
ubsdp решает задачу оптимизации 
    minimize(Tr(BX))
при условиях
    Tr(AiX) + ci = 0 (i = 1,n)  (*)
    0 =<  X <= I
    (код ubdsp взят с http://abel.ee.ucla.edu/cvxopt/examples/mlbook/ubsdp.html)
    
Задача релаксированная SDP задача для max-cut ставилась как (см. презентацию max_cut_sdp_slides.pdf страница 33 из 61)
    maximize (Tr(LX))
при условиях
    diag(x) = e
    X >= 0

Для задания того, что диагональные элементы матрицы X равны единице в (*)
надо вместо Ai подставлять матрицы размера (m,m) (X и L такого же размера)
и элемент aii = 1, а все остальные равны нулю. А сi = -1. 
Но, поскольку, наша задача (max-cut) это задача максимизации, а мы с помощью ubsdp
решаем задачу минимизации, то за место матрицы B надо поставить матрицу -L
(мы будем минимизировать Tr(-LX), а значит на данном Х ф-я Tr(-LX) будет иметь минимум, а Tr(LX) максимум)
L = 1/4 ( Diag(We) - W ) (см. презентацию)
"""

#Матрицу весов рёбер графа
W = matrix ([.2,.3,.22,.11,.23,
             .0,.34,.0,.1,.2,
             .10,.42,.1,.11,.33,
             .24,.34,.01,.31,.12,
             .76,.55,.1,.01,.23,]
            ,(5,5))
e = matrix([1.,1.,1.,1.,1.],(5,1))
# L = 1/4 ( Diag(We) - W )
L = 0.25*(spdiag(W*e) - W)
# берём эту матрицу с минусом
B = -L
# ci = -1 и у нас n условий (n=m=5)
c = matrix(-1., (5,1))
# A - матрица размеров (m**2,n) 
# для создания этой матрицы воспользуемся функцией sparse из cvxop
# Она "кладёт" одну матрицу на другую из двух матриц (n,n) получаем одну (2n,n)
A = matrix(0.0, (25,5))
for i in xrange(5):
    A[i*5 + i,i] = 1.
#решаем
X = ubsdp(c, A, B)
#берём случайные вектор
vec = normal(5,1)
#умножаем матрицу на него
sol = X*vec
for i in xrange(5):
    if sol[i] >= 0:
        sol[i] = 1
    else:
        sol[i] = -1
print sol
    
    
    
